@inject TemplateService TemplateService
@inject IJSRuntime JsRuntime

@foreach (var param in _templateParameters)
{
    @switch (param.Type)
    {
        case TemplateParameterType.Text:
            <div class="col min-col-width">
                <label for="@param.Id" class="form-label">@param.Name</label>
                <InputText id="@param.Id"
                           class="@("form-control form-control-sm mb-1 " + (param.Valid ? "is-valid" : "is-invalid"))"
                           @bind-Value="param.Value"
                           @bind-Value:after="AfterParameterChanged"/>
            </div>
            break;
        case TemplateParameterType.LongText:
            break;
        case TemplateParameterType.Select:
            <div class="col min-col-width">
                <label for="@param.Id" class="form-label">@param.Name</label>
                <InputSelect id="@param.Id"
                             class="@("form-select form-select-sm mb-1 " + (param.Valid ? "is-valid" : "is-invalid"))"
                             @bind-Value="param.Value"
                             @bind-Value:after="AfterParameterChanged">
                    <option selected disabled>Select</option>
                    @foreach (var option in param.Options)
                    {
                        <option value="@option">@option</option>
                    }
                </InputSelect>
            </div>
            break;
        default:
            throw new Exception($"Unknown parameter type {param.Type}");
    }
}
<div class="col-12 p-0"></div>
@foreach (var param in _templateParameters)
{
    @if (param.Type == TemplateParameterType.LongText)
    {
        <div class="col min-col-width">
            <label for="@param.Id" class="form-label">@param.Name</label>
            <InputTextArea id="@param.Id"
                           class="@("form-control form-control-sm mb-1 " + (param.Valid ? "is-valid" : "is-invalid"))"
                           @bind-Value="param.Value"
                           @bind-Value:after="AfterParameterChanged"/>
        </div>
    }
}

@code {
    [Parameter]
    public Template? Template { get; set; }

    [Parameter]
    public string? Context { get; set; }

    [Parameter]
    public EventCallback<string?> ContextChanged { get; set; }

    private TemplateParameter[] _templateParameters = [];
    private Template? _oldTemplate;
    private Guid? _focusToBeSet;

    protected override async Task OnParametersSetAsync()
    {
        // We are only interested in changes to the "Template" parameter
        if (Template == _oldTemplate) return;
        _oldTemplate = Template;
        await AfterTemplateChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_focusToBeSet == null) return;
        await JsRuntime.InvokeVoidAsync("setFocus", _focusToBeSet);
        _focusToBeSet = null;
    }

    private async Task AfterTemplateChanged()
    {
        await ContextChanged.InvokeAsync(null);
        if (Template != null)
        {
            _templateParameters = await TemplateService.GetTemplateParameters(Template);
            await AfterParameterChanged();
        }

        _focusToBeSet = _templateParameters.FirstOrDefault()?.Id;
    }

    private async Task AfterParameterChanged()
    {
        var valid = _templateParameters.All(p => p.Valid);
        if (!valid)
        {
            await ContextChanged.InvokeAsync(null);
            return;
        }

        var context = Template!.CalculateText(_templateParameters);
        await ContextChanged.InvokeAsync(context);
    }
}
