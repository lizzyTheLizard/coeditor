@inject UndoService UndoService
@inject IJSRuntime JsRuntime
@inject ConversationService ConversationService
@implements IDisposable

<div class="d-flex flex-column flex-grow-1">
    <InputTextArea id="editorTextarea"
                   disabled="@Disabled"
                   class="form-control flex-grow-1"
                   @bind-Value="Text"
                   @bind-Value:after="TextChanged"/>
    <div class="d-flex flex-wrap mx-n1">
        <EditorButton Disabled="@Disabled" OnTriggered="@HandleActionAsync"
                      ActionName="ActionName.Reformulate"></EditorButton>
        <EditorButton Disabled="@Disabled" OnTriggered="@HandleActionAsync"
                      ActionName="ActionName.Improve"></EditorButton>
        <EditorButton Disabled="@Disabled" OnTriggered="@HandleActionAsync"
                      ActionName="ActionName.Summarize"></EditorButton>
        <EditorButton Disabled="@Disabled" OnTriggered="@HandleActionAsync"
                      ActionName="ActionName.Expand"></EditorButton>
        <EditorButton Disabled="@(Disabled || !UndoService.CanUndo)"
                      OnTriggered="@Undo" Name="Undo"></EditorButton>
        <EditorButton Disabled="@(Disabled || !UndoService.CanRedo)"
                      OnTriggered="@Redo" Name="Redo"></EditorButton>
    </div>
    <DebugWindow></DebugWindow>
</div>

@code {
    [Parameter] public EventCallback<bool> IsBusyChanged { get; set; }

    private string Text { get; set; } = "";
    private bool Disabled => _isBusy || ConversationService.Current == null;
    private bool _isBusy = false;
    private ConversationChangeSubscription? _subscription;

    protected override void OnInitialized()
    {
        _subscription = ConversationService.RegisterOnConversationChange(ConversationChanged);
    }

    private void ConversationChanged(Conversation? c)
    {
        Text = c?.Text ?? "";
        if (c == null) UndoService.Clean();
        else UndoService.Register(Text);
    }

    private void TextChanged()
    {
        UndoService.Register(Text);
        ConversationService.Text = Text;
    }

    private async Task HandleActionAsync(ActionName actionName)
    {
        await SetBusyAsync(true);
        var selection = await GetSelectionAsync();
        await ConversationService.ApplyActionAsync(actionName, selection);
        await SetBusyAsync(false);
    }

    private void Undo()
    {
        Text = UndoService.Undo();
    }

    private void Redo()
    {
        Text = UndoService.Redo();
    }

    private async Task SetBusyAsync(bool value)
    {
        _isBusy = value;
        await IsBusyChanged.InvokeAsync(value);
        StateHasChanged();
    }

    private async Task<Selection?> GetSelectionAsync()
    {
        const string textareaId = "editorTextarea";
        var selectionStart = await JsRuntime.InvokeAsync<int>("getSelectionStart", textareaId);
        var selectionEnd = await JsRuntime.InvokeAsync<int>("getSelectionEnd", textareaId);
        return selectionStart == -1 || selectionEnd == -1 || selectionStart == selectionEnd
            ? null
            : new Selection(selectionStart, selectionEnd);
    }

    public void Dispose()
    {
        _subscription?.Dispose();
        _subscription = null;
    }

}
